<h1 align = "center">
  <img width="619" height="358" alt="image" src="https://github.com/user-attachments/assets/3cb812db-44ff-4085-a611-95b216fba1be" />
</h1>

# Cпособы остановки горутины в Go

В Go используется модель кооперативной отмены: горутина должна сама проверять сигнал о необходимости завершения и корректно прекращать свою работу. Не существует прямого способа принудительно остановить горутину извне.
*Ниже представлены 5 классических подходов для реализации этой модели, от самых простых и идиоматичных до более специфических и радикальных.*

## Первый способ *Выход по условию (цикл for range по каналу)*
Это один из самых простых способов завершения горутины. Он идеально подходит для сценариев, когда горутина `cat` обрабатывает задачи, поступающие из канала. Горутина работает, пока канал, из которого она читает данные, не будет закрыт. Цикл for range автоматически прекращается, когда это происходит. То есть горутина прекращает работу не по прямой команде

#### Цикл `for meow := range cats:` 
Горутина cat постоянно ждет новые данные (строки с "мяу") из канала cats. Цикл `for range` будет автоматически продолжаться, пока канал открыт и в нем есть данные.

#### `close(cats)` 
В главной функции main, после отправки всех котов, вызывается `close(cats)`
Эта команда не отправляет сообщение, а меняет состояние самого канала на "закрыт".

Как только горутина `cat` обработает все сообщения, которые уже были в буфере канала, `for range` обнаружит, что канал закрыт. В этот момент цикл корректно завершается.
После выхода из цикла горутина выполняет оставшийся код (в данном случае, defer wg.Done()) и прекращает свое существование.


##### Код "Тренируемся на кошках"
```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func cat(cats <-chan string, wg *sync.WaitGroup) {

	defer wg.Done()
	for meow := range cats {
		fmt.Println(meow)
		time.Sleep(500 * time.Millisecond)
	}
	fmt.Println("Проснулся злой сосед, прогнал всех котов с крыши и закрыл канал!")
}

func main() {
	cats := make(chan string, 5)
	var wg sync.WaitGroup

	wg.Add(1)
	go cat(cats, &wg)

	for i := 1; i <= 5; i++ {
		cats <- fmt.Sprintf("Кот %d говорит: Мяу!", i)
	}
	close(cats)
	wg.Wait()

	fmt.Println("Все коты ушли, на крыше тихо.")
}
```
#### Вывод программы
```bash
go run solution1.go      
Кот 1 говорит: Мяу!
Кот 2 говорит: Мяу!
Кот 3 говорит: Мяу!
Кот 4 говорит: Мяу!
Кот 5 говорит: Мяу!
Проснулся злой сосед, прогнал всех котов с крыши и закрыл канал!
Все коты ушли, на крыше тихо.
```

## Второй способ *Канал для уведомления*
Гибкий способ, который испульзует отдельный канал исключительно для отправки сигнала о необходимости завершения. Горутина использует `select`, чтобы ждать и полезную работу, и сигнал в `done` канале. Она кооперативно проверяет, не поступил ли ей сигнал к остановке, и сама корректно завершает свою работу, когда этот сигнал получен. Это явный и очень понятный способ контроля.

#### Создание канала done
В функции main создается канал `done := make(chan bool)`. Он не предназначен для передачи полезных данных, а играет роль простого переключателя.

#### Конструкция select
Внутри горутины student используется бесконечный цикл с `select`. Эта конструкция позволяет горутине одновременно "слушать" несколько каналов.

#### case <-done: 
Эта ветка ждет получения любого значения из канала done. Как только `main` отправляет туда сигнал `done <- true`, эта ветка выполняется, печатает сообщение и выходит из функции с помощью `return`, тем самым завершая горутину.

#### default: 
Эта ветка выполняется, если ни один из `case` в `select` не готов к выполнению (т.е. в канал done никто ничего не отправил). Это позволяет горутине продолжать свою основную работу ("Студент пишет лекцию..."), не блокируясь в ожидании сигнала.

#### Отправка сигнала
Главная горутина (main) решает, когда пора остановить `student`. Она отправляет сигнал `done <- true`, который и служит командой к завершению.

#### Код
```go
package main

import (
	"fmt"
	"time"
)

func student(done <-chan bool) {
	for {
		select {
		case <-done:
			fmt.Println("Получен сигнал, студент уснул...")
			return
		default:
			fmt.Println("Студент пишет лекцию...")
			time.Sleep(500 * time.Millisecond)
		}
	}
}

func main() {
	done := make(chan bool)

	go student(done)

	time.Sleep(2 * time.Second)
	done <- true

	time.Sleep(500 * time.Millisecond) 
}
```

#### Вывод программы
```bash
go run solution2.go
Студент пишет лекцию...
Студент пишет лекцию...
Студент пишет лекцию...
Студент пишет лекцию...
Получен сигнал, студент уснул...
```

## Третьий способ *Использование `context.Context`*
Это самый современный, мощный и предпочтительный способ управления отменой операций в Go. Он является стандартом для сетевых служб и сложных приложений, где сигнал об отмене должен распространяться по всей цепочке вызовов, например, при отмене HTTP-запроса пользователем. Ключевая идея: Контекст — это стандартный способ передать сигнал об отмене (а также таймауты и другие значения) через границы вызовов и между горутинами. Отмена родительского контекста автоматически отменяет все дочерние, что делает его идеальным для управления целыми деревьями операций.

#### Создание контекста 
`(context.WithCancel)` В функции main создается "контекст", который можно отменить. Функция `context.WithCancel` возвращает сам контекст (`ctx`) и функцию для его отмены (`cancel`), которую можно вызвать позже.

#### Передача контекста
Созданный `ctx` передается в горутину `worker` при ее запуске. Это стандартная практика — передавать контекст первым аргументом.

#### Ожидание сигнала (`select` и `ctx.Done()`)
Горутина worker в своем цикле использует `select`. Она ждет сигнала на канале, который возвращает метод `ctx.Done()`. Этот канал остается открытым до тех пор, пока контекст не будет отменен.

#### Отмена (`cancel()`)
В `main`, после двухсекундной паузы, вызывается функция `cancel()`. Этот вызов немедленно закрывает канал, ассоциированный с `ctx.Done()`.

#### Завершение горутины
Как только канал `Done()` закрывается, ветка `case <-ctx.Done()` в select немедленно срабатывает. Горутина печатает сообщение (включая причину отмены, которую возвращает `ctx.Err()`) и завершает свою работу с помощью `return`.


#### Код
```go
package main

import (
	"context"
	"fmt"
	"time"
)

func worker(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
			fmt.Println("Контекст отменен, горутина завершается:", ctx.Err())
			return
		default:
			fmt.Println("Горутина работает...")
			time.Sleep(500 * time.Millisecond)
		}
	}
}

func main() {

	ctx, cancel := context.WithCancel(context.Background())

	go worker(ctx)

	time.Sleep(2 * time.Second)
	cancel()

	time.Sleep(500 * time.Millisecond)
}
```

#### Вывод программы
```bash
go run solution3.go
Работаю...
Работаю...
Работаю...
Работаю...
Контекст отменен, горутина завершается: context canceled
```

## Четвертый способ *Прекращение работы через `runtime.Goexit()`*
Этот способ кардинально отличается от предыдущих. `runtime.Goexit()` — это функция, которая немедленно завершает выполнение только той горутины, которая ее вызвала. Это не механизм сигнализации извне, а команда "самоуничтожения" изнутри.
#### Запуск горутины
Горутина stubbornCat начинает свою работу, печатая сообщение.

#### `defer`
В самом начале функции stubbornCat устанавливается отложенный вызов `defer wg.Done()`. Это ключевой момент: Go гарантирует, что все отложенные вызовы будут выполнены перед тем, как горутина окончательно завершится, независимо от того, как она это сделает.

#### Вызов `runtime.Goexit()`
После того как в коде вызывается `runtime.Goexit()`, нормальное выполнение кода в горутине немедленно прекращается.

#### Недостижимый код
Любые строки кода, находящиеся после `runtime.Goexit()`, никогда не будут выполнены. "Кот уже вышел из чата".

#### Выполнение `defer` и завершение
Перед тем как горутина будет полностью уничтожена, среда выполнения Go запускает все ее отложенные defer вызовы. В вашем случае выполняется `wg.Done()`, что корректно сообщает главной горутине `main`, что работа завершена и можно продолжать.

#### Код "Продолжение с котами"
```go
package main

import (
	"fmt"
	"runtime"
	"sync"
	"time"
)

func stubbornCat(wg *sync.WaitGroup) {
	defer func() {
		fmt.Println("Снова тихая ночь во дворе...")
		wg.Done()
	}()

	fmt.Println("Упрямый кот из первого способа вернулся на крышу: 'Я же говорил, что вернусь!'")
	fmt.Println("Кот: 'Никто меня отсюда не прогонит! Это МОЯ крыша!'")
	fmt.Println()

	for i := 1; i <= 3; i++ {
		fmt.Printf("Упрямый кот (попытка %d): МЯЯЯЯЯУ!!! \n", i)
		time.Sleep(500 * time.Millisecond)
	}

	fmt.Println()
	fmt.Println("Разъяренный сосед швыряет ботинок")
	fmt.Println("ЛЕТЯЩИЙ БОТИНОК ПОПАДАЕТ В ЦЕЛЬ!")

	runtime.Goexit() // Экстренно завершаем горутину ("Летящий ботинок судьбы")

	// Эти строки никогда не выполнятся - кот уже "вышел из чата"
	fmt.Println("Кот: 'Почему вокруг так тихо?'")
	fmt.Println("Кот: 'Мяу? Мяу?? Кто-нибудь меня слышит???'")
}

func main() {
	var wg sync.WaitGroup

	fmt.Println("Тихая ночь во дворе...")
	fmt.Println("Все соседи уже спят после ночного инцидента с котами из первого способа.")
	fmt.Println()

	wg.Add(1)
	go stubbornCat(&wg)

	wg.Wait()

}
```

#### Вывод программы
```bash
go run solution4.go
Тихая ночь во дворе...
Все соседи уже спят после ночного инцидента с котами из первого способа.

Упрямый кот из первого способа вернулся на крышу: 'Я же говорил, что вернусь!'
Кот: 'Никто меня отсюда не прогонит! Это МОЯ крыша!'

Упрямый кот (попытка 1): МЯЯЯЯЯУ!!!
Упрямый кот (попытка 2): МЯЯЯЯЯУ!!!
Упрямый кот (попытка 3): МЯЯЯЯЯУ!!!

Разъяренный сосед швыряет ботинок
ЛЕТЯЩИЙ БОТИНОК ПОПАДАЕТ В ЦЕЛЬ!
Снова тихая ночь во дворе...
```

## Пятый способ *Радикальное завершение всей программы (`os.Exit`)*

Сам по себе этот способ - не способ остановки одной горутины, а принудительное завершение всего приложения. Вызов `os.Exit` немедленно прекращает работу программы, не давая другим горутинам шанса на корректное завершение. Этот метод следует использовать только в случае критических, невосстановимых ошибок.

#### Запуск горутины 
Горутина `worker` запускается и начинает свою работу. В ней есть отложенный вызов `defer` (`defer fmt.Println("Этот defer НЕ будет выполнен.")`).

#### Вызов `os.Exit`
Главная горутина `main` ждет одну секунду, а затем вызывает `os.Exit(1)`.

#### Мгновенное завершение
В момент вызова `os.Exit` вся программа, включая все активные горутины, немедленно останавливается и отложенные вызовы (defer) не выполняются. 
Это может привести к утечкам ресурсов (например, временные файлы не будут удалены, а сетевые соединения не будут закрыты), так как не происходит никакой очистки. Горутина worker просто "умирает" на полуслове.

#### Код
```go
package main

import (
	"fmt"
	"os"
	"time"
)

func worker() {
	defer fmt.Println("Этот defer НЕ будет выполнен.")
	time.Sleep(2 * time.Second)
	fmt.Println("Горутина завершила работу (не успеет).")
}

func main() {
	go worker()
	fmt.Println("Программа завершится через 1 секунду.")
	time.Sleep(1 * time.Second)
	os.Exit(1)
}
```

#### Вывод программы
```bash
go run solution5.go
Программа завершится через 1 секунду.
exit status 1
```
